<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic analysis of constraint-based models · COBREXA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="COBREXA.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="COBREXA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">COBREXA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../">Tutorials</a></li><li><a class="tocitem" href="../../notebooks/">Examples and notebooks</a></li><li><a class="tocitem" href="../../functions/">Function reference</a></li><li><a class="tocitem" href="../../howToContribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic analysis of constraint-based models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic analysis of constraint-based models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/tutorials/2_analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-analysis-of-constraint-based-models"><a class="docs-heading-anchor" href="#Basic-analysis-of-constraint-based-models">Basic analysis of constraint-based models</a><a id="Basic-analysis-of-constraint-based-models-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-analysis-of-constraint-based-models" title="Permalink"></a></h1><p><code>COBREXA.jl</code> supports several common analysis methods that are often used for exploring the biological models. The currently supported methods include</p><ul><li>Flux balance analysis (FBA), in function <a href="../../functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a></li><li>Flux variability analysis (FVA), in <a href="../../functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a></li><li>Flux sampling by hit-and-run algorithm, in <a href="../../functions/#COBREXA.hit_and_run-Tuple{Int64, Any}"><code>hit_and_run</code></a></li><li>Parsimonious flux balance analysis (pFBA), in <a href="../../functions/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>parsimonious_flux_balance_analysis</code></a></li></ul><p>Other analysis methods are either in development and testing, or may be specified or customized by the user. Implementing new analyses is generally feasible; you may want to watch <a href="https://github.com/LCSB-BioCore/COBREXA.jl">the <code>COBREXA.jl</code> repository</a> for newly incoming analysis methods.</p><p><code>COBREXA.jl</code> additionally exports several helper functions that may help you in running custom analysis methods:</p><ul><li>you can convert all types of <a href="../../functions/#COBREXA.MetabolicModel"><code>MetabolicModel</code></a>s to <code>JuMP.jl</code> models using <a href="../../functions/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}"><code>make_optimization_model</code></a>, then you may explore and analyze the models independently of <code>COBREXA.jl</code> using the tools provided by <code>JuMP.jl</code></li><li>there is a system of analysis <em>modifications</em> that allows you to easily specify various adjustments to the existing analysis methods</li></ul><div class="admonition is-success"><header class="admonition-header">Notebook available!</header><div class="admonition-body"><p>Examples of running the analysis functions are <a href="../../notebooks/2_finding_balance/">available here</a>.</p></div></div><h2 id="Optimization-problem-solvers"><a class="docs-heading-anchor" href="#Optimization-problem-solvers">Optimization problem solvers</a><a id="Optimization-problem-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-problem-solvers" title="Permalink"></a></h2><p>For solving most analysis tasks, you need an optimization problem solver that is compatible with <code>JuMP.jl</code>. You may refer to the <a href="https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers">official list of supported solvers</a>, but we generally recommend to use either of these:</p><ul><li><code>Tulip</code> (pure Julia implementation) for linear problems</li><li><code>GLPK</code> (based on a C library) for linear and mixed-integer problems</li><li><code>Gurobi</code> (based on an external library, but requires a license that is free for academic use) for linear, mixed-integer and quadratic problems</li><li><code>OSQP</code> as a free alternative to <code>Gurobi</code> for solving quadratic problems</li></ul><p>All solvers can be installed using the Julia package manger.</p><h2 id="Flux-balance-analysis"><a class="docs-heading-anchor" href="#Flux-balance-analysis">Flux balance analysis</a><a id="Flux-balance-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-balance-analysis" title="Permalink"></a></h2><p>The above methods generally accept 2 arguments: the model, and the optimizer.</p><p>In particular, having installed e.g. GLPK from the above optimizers, you can run FBA on <a href="http://bigg.ucsd.edu/models/e_coli_core">your favorite <em>E. Coli</em> core model</a> as follows:</p><pre><code class="language-none">using COBREXA
m = load_model(CoreModel, &quot;e_coli_core.xml&quot;)

using GLPK
opt_model = flux_balance_analysis(m, GLPK.Optimizer)</code></pre><p>After a short while (the solver machinery usually needs to get precompiled before the first use), you should get <code>opt_model</code>, which is now an optimized <code>JuMP.jl</code> model. It may print out information like this:</p><pre><code class="language-none">A JuMP Model
Maximization problem with:
Variables: 95
Objective function type: JuMP.GenericAffExpr{Float64,JuMP.VariableRef}
`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints
`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 192 constraints
Model mode: AUTOMATIC
CachingOptimizer state: ATTACHED_OPTIMIZER
Solver name: GLPK
Names registered in the model: lbs, mb, ubs, x</code></pre><p>From that, you can extract the required information with the JuMP interface, loaded with <code>using JuMP</code>. With that,</p><ul><li><code>objective_value(opt_model)</code> prints roughly <code>0.87</code>,</li><li><code>value.(opt_model[:x])</code> prints the vector of individual reaction fluxes.</li></ul><p>For convenience, you can get the results nicely formatted without manually getting them out of the optimized models:</p><ul><li><a href="../../functions/#COBREXA.flux_balance_analysis_vec-Tuple"><code>flux_balance_analysis_vec</code></a> works like <a href="../../functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>, but returns the vector of fluxes directly (in the same order as in <code>reactions(m)</code>)</li><li><a href="../../functions/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}"><code>flux_balance_analysis_dict</code></a> returns a dictionary with the fluxes, keyed by reaction identifier</li></ul><h2 id="Flux-variability-analysis"><a class="docs-heading-anchor" href="#Flux-variability-analysis">Flux variability analysis</a><a id="Flux-variability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-variability-analysis" title="Permalink"></a></h2><p>FVA is implemented in <a href="../../functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a>, which returns the usual matrix of minimal and maximal feasible fluxes for each reaction in the model.</p><p>The result of calling <code>flux_variability_analysis(m, GLPK.Optimizer)</code> may look like this (possibly showing minor numeric errors in the GLPK optimizer):</p><pre><code class="language-none">95×2 Array{Float64,2}:
   0.0            0.0
   6.00725        6.00725
   ⋮            
   3.64414e-13    3.17348e-13
   3.2149         3.2149</code></pre><p>You can relax the optimality requirement of the reactions by specifying a wider objective bound, getting a wider range of reaction fluxes, e.g. using <a href="../../functions/#COBREXA.gamma_bounds-Tuple{Any}"><code>gamma_bounds</code></a> (for COBRA-like γ-bound) and <a href="../../functions/#COBREXA.objective_bounds-Tuple{Any}"><code>objective_bounds</code></a> (for a multiplicative bound around the original optimal objective).</p><p>As a result, <code>flux_variability_analysis(m, GLPK.Optimizer; bounds=gamma_bounds(0.8))</code> will return a much less constrained system:</p><pre><code class="language-none">95×2 Array{Float64,2}:
   0.0            0.0
   0.754299      10.1285
   ⋮            
  -4.42865        0.0
   2.57192        3.2149</code></pre><p>You may additionally restrict the analysis to a list of reactions (passing the list as the second argument, see documentation of <a href="../../functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis</code></a>), or retrieve a dictionary of the resulting fluxes with <a href="../../functions/#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}"><code>flux_variability_analysis_dict</code></a>.</p><h2 id="Parsimonious-flux-balance-analysis"><a class="docs-heading-anchor" href="#Parsimonious-flux-balance-analysis">Parsimonious flux balance analysis</a><a id="Parsimonious-flux-balance-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Parsimonious-flux-balance-analysis" title="Permalink"></a></h2><p>Parsimonious flux balance analysis (pFBA) requires a solver that can handle quadratic problems. You may use e.g. <code>OSQP</code> or <code>Gurobi</code>.</p><p>Otherwise, the function behaves just like <a href="../../functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>:</p><ul><li><a href="../../functions/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}"><code>parsimonious_flux_balance_analysis</code></a><code>(m, OSQP.Optimizer)</code> will return a <code>JuMP.jl</code> model optimized to a slightly more realistic (parsimonious) optimum than plain FBA,</li><li><a href="../../functions/#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple"><code>parsimonious_flux_balance_analysis_vec</code></a> will return the fluxes in a vector,</li><li><a href="../../functions/#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}"><code>parsimonious_flux_balance_analysis_dict</code></a> will return a reaction-keyed dictionary.</li></ul><h2 id="Flux-sampling"><a class="docs-heading-anchor" href="#Flux-sampling">Flux sampling</a><a id="Flux-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-sampling" title="Permalink"></a></h2><p>For the <a href="../../functions/#COBREXA.hit_and_run-Tuple{Int64, Any}"><code>hit_and_run</code></a>, you need a previously optimized and constrained model from another analysis function, such as <a href="../../functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:MetabolicModel"><code>flux_balance_analysis</code></a>, or created by <a href="../../functions/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}"><code>make_optimization_model</code></a>. You may need to carefully choose the number of iterations and sample sizes to match your model; see the documentation of <a href="../../functions/#COBREXA.hit_and_run-Tuple{Int64, Any}"><code>hit_and_run</code></a> for details.</p><p>As an example, you can run the sampling for 100 thousand iterations with:</p><pre><code class="language-none">hit_and_run(100_000, make_optimization_model(m, GLPK.Optimizer))</code></pre><p>You should receive a matching flux sample with the (default) 1000 samples in a matrix that may look like this one:</p><pre><code class="language-none">95×1000 Array{Float64,2}:
   0.0           0.0         …   0.0
   7.82669       9.38895         3.30653
   7.13016       4.36813         9.64434
  -0.290925     -9.3037         -0.0908829
  24.1294       17.4794          0.0511032
   ⋮                         ⋱  
 -16.243       -37.4763         -5.57301
   0.0           0.0             0.0
  -0.310819     -1.20057e-7     -2.13126
   5.71597e-5    0.00990677      0.692399</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 11 May 2021 17:13">Tuesday 11 May 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
